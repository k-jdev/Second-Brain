Tags: #теоретичний_мінмум_по_CS #стратегія #programming

Мы говорим о рекурсии, когда функция делегирует работу своим клонам. Рекурсивный алгоритм естественным образом приходит на ум, когда нужно решить задачу, сформулированную с точки зрения самой себя. Например, возьмем известную последовательность Фибоначчи. Она начинается с двух единиц, и каждое последующее число является суммой двух предыдущих: 1, 1, 2, 3, 5, 8, 13, 21. Как создать функцию, возвращающую n-е число Фибоначчи (рис. 3.3)?

![[Pasted image 20241202165121.png]]


``` js
function fib(number) {
  if (number <= 1) {
    return number;
  }
  return fib(number - 1) + fib(number - 2);
}
  
console.log(fib(10)); //55
```
При использовании рекурсии требуется творческий подход, чтобы понять, каким образом задача может быть поставлена с точки зрения самой себя. Чтобы проверить, является ли слово [[палиндромом]], нужно посмотреть, изменится ли оно, если его перевернуть. Это можно сделать, проверив, одинаковы ли первая и последняя буквы слова и не является ли палиндромом заключенная между ними часть слова (рис. 3.4).

![[Pasted image 20241202165408.png]]


```js
function palindrome(word)
····if word.length ≤ 1
········return True
····if word.first_char ≠ word.last_char
········return False
····w ← word.remove_first_and_last_chars
····return palindrome(w)
```
Рекурсивные алгоритмы имеют базовые случаи, когда объем входных данных слишком мал, чтобы его можно было продолжать сокращать. Базовые случаи для функции fib — числа 1 и 2; для функции palindrome это слова, состоящие из единственной буквы или не имеющие ни одной буквы.